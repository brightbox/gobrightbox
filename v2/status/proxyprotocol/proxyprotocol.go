// Code generated by generate_enum; DO NOT EDIT.

package proxyprotocol

import "fmt"

// Status is an enumerated type
type Status uint8

const (
	// V1 is an enumeration for proxyprotocol.Status
	V1 Status = iota + 1
	// V2 is an enumeration for Status
	V2
	// V2Ssl is an enumeration for Status
	V2Ssl
	// V2SslCn is an enumeration for Status
	V2SslCn
)

// Set of strings that are valid inputs for ParseStatus
var ValidStrings = []string{
	V1.String(),
	V2.String(),
	V2Ssl.String(),
	V2SslCn.String(),
}

// String makes Status satisfy the Stringer interface
func (i Status) String() string {
	tmp, err := i.MarshalText()
	if err == nil {
		return string(tmp)
	}
	return ""
}

// ParseStatus attempts to convert a string into a Status
func ParseStatus(name string) (Status, error) {
	switch name {
	case "v1":
		return V1, nil
	case "v2":
		return V2, nil
	case "v2-ssl":
		return V2Ssl, nil
	case "v2-ssl-cn":
		return V2SslCn, nil
	}
	return Status(0), fmt.Errorf("%s is not a valid proxyprotocol.Status", name)
}

// MarshalText implements the text marshaller method
func (i Status) MarshalText() ([]byte, error) {
	switch i {
	case V1:
		return []byte("v1"), nil
	case V2:
		return []byte("v2"), nil
	case V2Ssl:
		return []byte("v2-ssl"), nil
	case V2SslCn:
		return []byte("v2-ssl-cn"), nil
	}
	return nil, fmt.Errorf("%d is not a valid proxyprotocol.Status", i)
}

// UnmarshalText implements the text unmarshaller method
func (i *Status) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseStatus(name)
	if err != nil {
		return err
	}
	*i = tmp
	return nil
}
