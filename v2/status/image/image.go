// Code generated by generate_enum; DO NOT EDIT.

package image

import "fmt"

// Status is an enumerated type
type Status uint8

const (
	// Creating is an enumeration for image.Status
	Creating Status = iota + 1
	// Available is an enumeration for Status
	Available
	// Deprecated is an enumeration for Status
	Deprecated
	// Unavailable is an enumeration for Status
	Unavailable
	// Deleting is an enumeration for Status
	Deleting
	// Deleted is an enumeration for Status
	Deleted
	// Failed is an enumeration for Status
	Failed
)

// Set of strings that are valid inputs for ParseStatus
var ValidStrings = []string{
	Creating.String(),
	Available.String(),
	Deprecated.String(),
	Unavailable.String(),
	Deleting.String(),
	Deleted.String(),
	Failed.String(),
}

// String makes Status satisfy the Stringer interface
func (i Status) String() string {
	tmp, err := i.MarshalText()
	if err == nil {
		return string(tmp)
	}
	return ""
}

// ParseStatus attempts to convert a string into a Status
func ParseStatus(name string) (Status, error) {
	switch name {
	case "creating":
		return Creating, nil
	case "available":
		return Available, nil
	case "deprecated":
		return Deprecated, nil
	case "unavailable":
		return Unavailable, nil
	case "deleting":
		return Deleting, nil
	case "deleted":
		return Deleted, nil
	case "failed":
		return Failed, nil
	}
	return Status(0), fmt.Errorf("%s is not a valid image.Status", name)
}

// MarshalText implements the text marshaller method
func (i Status) MarshalText() ([]byte, error) {
	switch i {
	case Creating:
		return []byte("creating"), nil
	case Available:
		return []byte("available"), nil
	case Deprecated:
		return []byte("deprecated"), nil
	case Unavailable:
		return []byte("unavailable"), nil
	case Deleting:
		return []byte("deleting"), nil
	case Deleted:
		return []byte("deleted"), nil
	case Failed:
		return []byte("failed"), nil
	}
	return nil, fmt.Errorf("%d is not a valid image.Status", i)
}

// UnmarshalText implements the text unmarshaller method
func (i *Status) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseStatus(name)
	if err != nil {
		return err
	}
	*i = tmp
	return nil
}
