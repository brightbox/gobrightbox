#!/usr/bin/env ruby

require 'fileutils'

def snake_case(str)
  return str.downcase if str =~ /\A[A-Z]+\z/
  str.gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
     .gsub(/([a-z])([A-Z])/, '\1_\2')
     .downcase
end

def make_identifier(str)
  str.split(/[_-](?!\d)/).collect(&:capitalize).join
end

def generate_enumeration(file_name, package_name, states)
  File.open(file_name, 'w') do |f|
    f << file_header(package_name)
    f << generate_states(package_name, states)
    f << generate_valid_strings(states)
    f << stringer
    f << generate_parser(package_name, states)
    f << generate_marshal(package_name, states)
    f << unmarshal_text
  end
end

def file_header(package_name)
  <<-ENDFUNC
// Code generated by generate_enum; DO NOT EDIT.

package #{package_name}

import "fmt"

  ENDFUNC
end

def generate_states(package_name, states)
  first = make_identifier(states[0])
  result = <<-FIRST
// Status is an enumerated type
type Status uint8

const (
  // #{first} is an enumeration for #{package_name}.Status
	#{first} Status = iota + 1
  FIRST
  states[1..-1].reduce(result) do |memo, state|
    identifier = make_identifier(state)
    memo << <<-NEXT
	// #{identifier} is an enumeration for Status
	#{identifier}
    NEXT
  end << <<-FINAL
)

FINAL
end

def generate_valid_strings(states)
  result = <<-FIRST
// Set of strings that are valid inputs for ParseStatus
var ValidStrings = []string{
  FIRST
  states.reduce(result) do |result, state|
    result << <<-NEXT
    #{make_identifier(state)}.String(),
    NEXT
  end << <<-FINAL
	}

FINAL
end

def stringer
  <<-ENDFUNC
// String makes Status satisfy the Stringer interface
func (i Status) String() string {
	tmp, err := i.MarshalText()
	if err == nil {
		return string(tmp)
	}
	return ""
}

  ENDFUNC
end

def generate_parser(package_name, states)
  result = <<-FIRST
// ParseStatus attempts to convert a string into a Status
func ParseStatus(name string) (Status, error) {
	switch name {
  FIRST
  states.reduce(result) do |result, state|
    result << <<-NEXT
	case "#{state.downcase}":
		return #{make_identifier(state)}, nil
    NEXT
  end << <<-FINAL
	}
  return Status(0), fmt.Errorf("%s is not a valid #{package_name}.Status", name)
}

FINAL
end

def generate_marshal(package_name, states)
  result = <<-FIRST
// MarshalText implements the text marshaller method
func (i Status) MarshalText() ([]byte, error) {
	switch i {
  FIRST
  states.reduce(result) do |result, state|
    result << <<-NEXT
	case #{make_identifier(state)}:
		return []byte("#{state.downcase}"), nil
    NEXT
  end << <<-FINAL
	}
  return nil, fmt.Errorf("%v is not a valid #{package_name}.Status", i)
}

FINAL
end

def unmarshal_text
  <<-ENDFUNC
// UnmarshalText implements the text unmarshaller method
func (i *Status) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseStatus(name)
	if err != nil {
		return err
	}
	*i = tmp
	return nil
}

  ENDFUNC
end

package_name = ARGV.shift
if package_name.to_s.empty? || ARGV.empty?
  STDERR.puts('Need a package name and at least one enumeration')
  exit 1
end
FileUtils.mkdir_p(File.join('status', package_name))
file_name = File.join('status', package_name, "#{package_name}.go")
generate_enumeration(file_name, package_name, ARGV)
exec('gofmt', '-w', file_name)
