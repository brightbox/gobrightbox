#!/usr/bin/env ruby
# Generate Default Command and Tests from supplied yaml file

require 'yaml'

def generate_default_tested_api_commands(struct, options)
  file_prefix = options['path'].downcase
  generate_default_api_commands(struct, options, "#{file_prefix}_default.go")
  generate_default_test_commands(struct, options, "#{file_prefix}_default_test.go")
  %W[#{file_prefix}_default.go #{file_prefix}_default_test.go]
end

def generate_default_api_commands(struct, options, output_filename)
  plural = options['plural'] || "#{struct}s"
  File.open(output_filename, 'w') do |f|
    f << file_header
    f << "import \"fmt\"\n\n" if options['crud'].include?('handle')
    f << path_constant(struct, options['path'])
    f << collection_function(struct, plural)
    f << instance_function(struct)
    f << instance_by_handle_function(struct, plural) if options['crud'].include?('handle')
    f << create_function(struct) if options['crud'].include?('create')
    f << update_function(struct) if options['crud'].include?('update')
    f << destroy_function(struct) if options['crud'].include?('delete')
    f << lock_functions(struct) if options['crud'].include?('lock')
    f << reset_password_function(struct, options['password']) if options['password']
  end
end

def generate_default_test_commands(struct, options, output_filename)
  plural = options['plural'] || "#{struct}s"
  path = options['path']
  File.open(output_filename, 'w') do |f|
    f << test_file_header
    f << test_collection_function(struct, plural, options)
    f << test_instance_function(struct, options)
    f << test_instance_by_handle_function(struct, options) if options['crud'].include?('handle')
    f << test_create_function(struct, options) if options['crud'].include?('create')
    f << test_update_function(struct, options) if options['crud'].include?('update')
    f << test_destroy_function(struct, options) if options['crud'].include?('delete')
    f << test_lock_functions(struct, options) if options['crud'].include?('lock')
    f << test_reset_password_function(struct, options) if options['password']
  end
end

def test_file_header
  <<-ENDFUNC
// Code generated by go generate; DO NOT EDIT.

package brightbox

import (
	"path"
	"testing"

	"gotest.tools/v3/assert"
)

  ENDFUNC
end

def test_collection_function(struct, plural, options)
  <<-ENDFUNC
func Test#{plural}(t *testing.T) {
	instance := testAll[#{struct}](
		t,
		(*Client).#{plural},
		"#{struct}",
		"#{options['path']}",
		"#{plural}",
	)
	assert.Equal(t, instance.ID, "#{options['testid']}")
}

  ENDFUNC
end

def test_instance_function(struct, options)
  <<-ENDFUNC
func Test#{struct}(t *testing.T) {
	instance := testInstance[#{struct}](
		t,
		(*Client).#{struct},
		"#{struct}",
    path.Join("#{options['path']}", "#{options['testid']}"),
    "#{options['jsonpath']}",
		"#{options['testid']}",
	)
	assert.Equal(t, instance.ID, "#{options['testid']}")
}

  ENDFUNC
end

def test_instance_by_handle_function(struct, options)
  <<-ENDFUNC
func Test#{struct}ByHandle(t *testing.T) {
	instance := testInstance[#{struct}](
		t,
		(*Client).#{struct},
		"#{struct}",
    path.Join("#{options['path']}", "#{options['testid']}"),
    "#{options['jsonpath']}",
		"#{options['testid']}",
	)
	assert.Equal(t, instance.ID, "#{options['testid']}")
	handleInstance := testInstance[#{struct}](
		t,
		(*Client).#{struct}ByHandle,
		"#{struct}",
    path.Join("#{options['path']}"),
    "#{options['path']}",
    instance.Handle,
	)
  assert.Equal(t, instance.ID, handleInstance.ID)
}

  ENDFUNC
end

def test_create_function(struct, options)
  <<-ENDFUNC
func TestCreate#{struct}(t *testing.T) {
	newResource := #{struct}Options{}
	instance := testModify[#{struct}, *#{struct}Options](
		t,
		(*Client).Create#{struct},
		&newResource,
    "#{options['jsonpath']}",
		"POST",
    path.Join("#{options['path']}"),
		"{}",
	)
	assert.Equal(t, instance.ID, "#{options['testid']}")
}

  ENDFUNC
end

def test_update_function(struct, options)
  <<-ENDFUNC
func TestUpdate#{struct}(t *testing.T) {
	updatedResource := #{struct}Options{ID: "#{options['testid']}"}
	instance := testModify[#{struct}, *#{struct}Options](
		t,
		(*Client).Update#{struct},
		&updatedResource,
    "#{options['jsonpath']}",
		"PUT",
    path.Join("#{options['path']}", updatedResource.ID),
		"{}",
	)
  assert.Equal(t, instance.ID, updatedResource.ID)
}

  ENDFUNC
end

def test_destroy_function(struct, options)
  <<-ENDFUNC
func TestDestroy#{struct}(t *testing.T) {
	testCommand(
		t,
		(*Client).Destroy#{struct},
		"#{options['testid']}",
		"DELETE",
    path.Join("#{options['path']}", "#{options['testid']}"),
	)
}

  ENDFUNC
end

def test_lock_functions(struct, options)
  <<-ENDFUNC
func TestLock#{struct}(t *testing.T) {
	testCommand(
		t,
		(*Client).Lock#{struct},
		"#{options['testid']}",
		"PUT",
    path.Join("#{options['path']}", "#{options['testid']}", "lock_resource"),
	)
}

func TestUnlock#{struct}(t *testing.T) {
	testCommand(
		t,
		(*Client).Unlock#{struct},
		"#{options['testid']}",
		"PUT",
    path.Join("#{options['path']}", "#{options['testid']}", "unlock_resource"),
	)
}

  ENDFUNC
end

def test_reset_password_function(struct, options)
  <<-ENDFUNC
func TestReset#{struct}Password(t *testing.T) {
	instance := testModify[#{struct}, string](
		t,
		(*Client).Reset#{struct}Password,
		"#{options['testid']}",
		"#{options['jsonpath']}",
		"POST",
		path.Join("#{options['path']}", "#{options['testid']}", "#{options['password']}"),
		"",
	)
	assert.Equal(t, instance.ID, "#{options['testid']}")
}

  ENDFUNC
end

def file_header
  <<-ENDFUNC
// Code generated by go generate; DO NOT EDIT.

package brightbox

import "context"
import "path"

  ENDFUNC
end

def path_constant(struct, pathname)
  <<-ENDFUNC
const (
	// #{struct}APIPath returns the relative URL path to the #{struct} endpoint
	#{struct}APIPath = "#{pathname}"
)

  ENDFUNC
end

def collection_function(struct, plural)
  <<-ENDFUNC
// #{plural} returns the collection view for #{struct}
func (c *Client) #{plural}(ctx context.Context) ([]#{struct}, error) {
  return APIGetCollection[#{struct}](ctx, c, #{struct}APIPath)
}

  ENDFUNC
end

def instance_function(struct)
  <<-ENDFUNC
// #{struct} retrieves a detailed view of one resource
func (c *Client) #{struct}(ctx context.Context, identifier string) (*#{struct}, error) {
	return APIGet[#{struct}](ctx, c, path.Join(#{struct}APIPath, identifier))
}

  ENDFUNC
end

def instance_by_handle_function(struct, plural)
  <<-ENDFUNC

// #{struct} retrieves a detailed view of one resource using a handle
func (c *Client) #{struct}ByHandle(ctx context.Context, handle string) (*#{struct}, error) {
  collection, err := c.#{plural}(ctx)
	if err != nil {
		return nil, err
	}
	for _, instance := range collection {
    if instance.Handle == handle {
			return &instance, nil
		}
	}
	return nil, fmt.Errorf("Resource with handle '%s' doesn't exist", handle)
}

  ENDFUNC
end

def create_function(struct)
  <<-ENDFUNC
// Create#{struct} creates a new resource from the supplied option map.
//
// It takes an instance of #{struct}Options. Not all attributes can be
// specified at create time (such as ID, which is allocated for you).
func (c *Client) Create#{struct}(ctx context.Context, new#{struct} *#{struct}Options) (*#{struct}, error) {
	return APIPost[#{struct}](ctx, c, #{struct}APIPath, new#{struct})
}

  ENDFUNC
end
 
def update_function(struct)
  <<-ENDFUNC
// Update#{struct} updates an existing resources's attributes. Not all
// attributes can be changed (such as ID).
//
// It takes an instance of #{struct}Options. Specify the resource you
// want to update using the ID field.
func (c *Client) Update#{struct}(ctx context.Context, update#{struct} *#{struct}Options) (*#{struct}, error) {
	return APIPut[#{struct}](ctx, c, path.Join(#{struct}APIPath, update#{struct}.ID), update#{struct})
}

  ENDFUNC
end

def destroy_function(struct)
  <<-ENDFUNC
// Destroy#{struct} destroys an existing resource.
func (c *Client) Destroy#{struct}(ctx context.Context, identifier string) error {
	return APIDelete(ctx, c, path.Join(#{struct}APIPath, identifier))
}

  ENDFUNC
end

def lock_functions(struct)
  <<-ENDFUNC
// Lock#{struct} locks a resource against destroy requests
func (c *Client) Lock#{struct}(ctx context.Context, identifier string) error {
	return APIPutCommand(ctx, c, path.Join(#{struct}APIPath, identifier, "lock_resource"))
}

// Unlock#{struct} unlocks a resource, re-enabling destroy requests
func (c *Client) Unlock#{struct}(ctx context.Context, identifier string) error {
	return APIPutCommand(ctx, c, path.Join(#{struct}APIPath, identifier, "unlock_resource"))
}
  ENDFUNC
end

def reset_password_function(struct, endpoint)
  <<-ENDFUNC
// Reset#{struct}Password resets the password in #{struct}, returning it 
// in the returned resource. This is the only time the new password is
// available in plaintext.
func (c *Client) Reset#{struct}Password(ctx context.Context, identifier string) (*#{struct}, error) {
  return APIPost[#{struct}](ctx, c, path.Join(#{struct}APIPath, identifier, "#{endpoint}"), nil)
}

  ENDFUNC
end

object_hash = YAML.safe_load(ARGF.read)
files = %w[gofmt -w]
object_hash.each { |k, v| files << generate_default_tested_api_commands(k, v) }
exec(*files.flatten)
